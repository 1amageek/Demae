{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _url = require(\"url\");\n\nvar _mitt = _interopRequireDefault(require(\"../next-server/lib/mitt\"));\n\nvar _isDynamic = require(\"./../next-server/lib/router/utils/is-dynamic\");\n\nvar _routeMatcher = require(\"./../next-server/lib/router/utils/route-matcher\");\n\nvar _routeRegex = require(\"./../next-server/lib/router/utils/route-regex\");\n\nvar _router = require(\"./../next-server/lib/router/router\");\n\nfunction hasRel(rel, link) {\n  try {\n    link = document.createElement('link');\n    return link.relList.supports(rel);\n  } catch (_unused) {}\n}\n\nvar relPrefetch = hasRel('preload') && !hasRel('prefetch') ? // https://caniuse.com/#feat=link-rel-preload\n// macOS and iOS (Safari does not support prefetch)\n'preload' : // https://caniuse.com/#feat=link-rel-prefetch\n// IE 11, Edge 12+, nearly all evergreen\n'prefetch';\nvar hasNoModule = ('noModule' in document.createElement('script'));\n/** @param {string} route */\n\nfunction normalizeRoute(route) {\n  if (route[0] !== '/') {\n    throw new Error(\"Route name should start with a \\\"/\\\", got \\\"\".concat(route, \"\\\"\"));\n  }\n\n  route = route.replace(/\\/index$/, '/');\n  if (route === '/') return route;\n  return route.replace(/\\/$/, '');\n}\n\nfunction appendLink(href, rel, as) {\n  return new Promise(function (res, rej, link) {\n    link = document.createElement('link');\n    link.crossOrigin = process.crossOrigin;\n    link.href = href;\n    link.rel = rel;\n    if (as) link.as = as;\n    link.onload = res;\n    link.onerror = rej;\n    document.head.appendChild(link);\n  });\n}\n\nvar PageLoader = /*#__PURE__*/function () {\n  function PageLoader(buildId, assetPrefix) {\n    _classCallCheck(this, PageLoader);\n\n    this.buildId = buildId;\n    this.assetPrefix = assetPrefix;\n    this.pageCache = {};\n    this.pageRegisterEvents = (0, _mitt[\"default\"])();\n    this.loadingRoutes = {};\n\n    if (process.env.__NEXT_GRANULAR_CHUNKS) {\n      this.promisedBuildManifest = new Promise(function (resolve) {\n        if (window.__BUILD_MANIFEST) {\n          resolve(window.__BUILD_MANIFEST);\n        } else {\n          window.__BUILD_MANIFEST_CB = function () {\n            resolve(window.__BUILD_MANIFEST);\n          };\n        }\n      });\n    }\n    /** @type {Promise<Set<string>>} */\n\n\n    this.promisedSsgManifest = new Promise(function (resolve) {\n      if (window.__SSG_MANIFEST) {\n        resolve(window.__SSG_MANIFEST);\n      } else {\n        window.__SSG_MANIFEST_CB = function () {\n          resolve(window.__SSG_MANIFEST);\n        };\n      }\n    });\n  } // Returns a promise for the dependencies for a particular route\n\n\n  _createClass(PageLoader, [{\n    key: \"getDependencies\",\n    value: function getDependencies(route) {\n      var _this = this;\n\n      return this.promisedBuildManifest.then(function (man) {\n        return man[route] && man[route].map(function (url) {\n          return \"\".concat(_this.assetPrefix, \"/_next/\").concat(encodeURI(url));\n        }) || [];\n      });\n    }\n    /**\n    * @param {string} href the route href (file-system path)\n    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n    */\n\n  }, {\n    key: \"getDataHref\",\n    value: function getDataHref(href, asPath) {\n      var _this2 = this;\n\n      var getHrefForSlug =\n      /** @type string */\n      function getHrefForSlug(path) {\n        path = (0, _router.delBasePath)(path);\n        return \"\".concat(_this2.assetPrefix, \"/_next/data/\").concat(_this2.buildId).concat(path === '/' ? '/index' : path, \".json\");\n      };\n\n      var _ref = (0, _url.parse)(href, true),\n          hrefPathname = _ref.pathname,\n          query = _ref.query;\n\n      var _ref2 = (0, _url.parse)(asPath),\n          asPathname = _ref2.pathname;\n\n      var route = normalizeRoute(hrefPathname);\n      var isDynamic = (0, _isDynamic.isDynamicRoute)(route),\n          interpolatedRoute;\n\n      if (isDynamic) {\n        var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);\n        var dynamicGroups = dynamicRegex.groups;\n        var dynamicMatches = // Try to match the dynamic route against the asPath\n        (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) || // Fall back to reading the values from the href\n        // TODO: should this take priority; also need to change in the router.\n        query;\n        interpolatedRoute = route;\n\n        if (!Object.keys(dynamicGroups).every(function (param) {\n          var value = dynamicMatches[param];\n          var repeat = dynamicGroups[param].repeat; // support single-level catch-all\n          // TODO: more robust handling for user-error (passing `/`)\n\n          if (repeat && !Array.isArray(value)) value = [value];\n          return param in dynamicMatches && ( // Interpolate group into data URL if present\n          interpolatedRoute = interpolatedRoute.replace(\"[\".concat(repeat ? '...' : '').concat(param, \"]\"), repeat ? value.map(encodeURIComponent).join('/') : encodeURIComponent(value)));\n        })) {\n          interpolatedRoute = ''; // did not satisfy all requirements\n          // n.b. We ignore this error because we handle warning for this case in\n          // development in the `<Link>` component directly.\n        }\n      }\n\n      return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);\n    }\n    /**\n    * @param {string} href the route href (file-system path)\n    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n    */\n\n  }, {\n    key: \"prefetchData\",\n    value: function prefetchData(href, asPath) {\n      var _this3 = this;\n\n      var _ref3 = (0, _url.parse)(href, true),\n          hrefPathname = _ref3.pathname;\n\n      var route = normalizeRoute(hrefPathname);\n      return this.promisedSsgManifest.then(function (s, _dataHref) {\n        return (// Check if the route requires a data file\n          s.has(route) && ( // Try to generate data href, noop when falsy\n          _dataHref = _this3.getDataHref(href, asPath)) && // noop when data has already been prefetched (dedupe)\n          !document.querySelector(\"link[rel=\\\"\".concat(relPrefetch, \"\\\"][href^=\\\"\").concat(_dataHref, \"\\\"]\")) && // Inject the `<link rel=prefetch>` tag for above computed `href`.\n          appendLink(_dataHref, relPrefetch, 'fetch')\n        );\n      });\n    }\n  }, {\n    key: \"loadPage\",\n    value: function loadPage(route) {\n      return this.loadPageScript(route);\n    }\n  }, {\n    key: \"loadPageScript\",\n    value: function loadPageScript(route) {\n      var _this4 = this;\n\n      route = normalizeRoute(route);\n      return new Promise(function (resolve, reject) {\n        var fire = function fire(_ref4) {\n          var error = _ref4.error,\n              page = _ref4.page,\n              mod = _ref4.mod;\n\n          _this4.pageRegisterEvents.off(route, fire);\n\n          delete _this4.loadingRoutes[route];\n\n          if (error) {\n            reject(error);\n          } else {\n            resolve({\n              page: page,\n              mod: mod\n            });\n          }\n        }; // If there's a cached version of the page, let's use it.\n\n\n        var cachedPage = _this4.pageCache[route];\n\n        if (cachedPage) {\n          var error = cachedPage.error,\n              page = cachedPage.page,\n              mod = cachedPage.mod;\n          error ? reject(error) : resolve({\n            page: page,\n            mod: mod\n          });\n          return;\n        } // Register a listener to get the page\n\n\n        _this4.pageRegisterEvents.on(route, fire); // If the page is loading via SSR, we need to wait for it\n        // rather downloading it again.\n\n\n        if (document.querySelector(\"script[data-next-page=\\\"\".concat(route, \"\\\"]\"))) {\n          return;\n        }\n\n        if (!_this4.loadingRoutes[route]) {\n          _this4.loadingRoutes[route] = true;\n\n          if (process.env.__NEXT_GRANULAR_CHUNKS) {\n            _this4.getDependencies(route).then(function (deps) {\n              deps.forEach(function (d) {\n                if (/\\.js$/.test(d) && !document.querySelector(\"script[src^=\\\"\".concat(d, \"\\\"]\"))) {\n                  _this4.loadScript(d, route, false);\n                }\n\n                if (/\\.css$/.test(d) && !document.querySelector(\"link[rel=stylesheet][href^=\\\"\".concat(d, \"\\\"]\"))) {\n                  appendLink(d, 'stylesheet')[\"catch\"](function () {// FIXME: handle failure\n                    // Right now, this is needed to prevent an unhandled rejection.\n                  });\n                }\n              });\n\n              _this4.loadRoute(route);\n            });\n          } else {\n            _this4.loadRoute(route);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"loadRoute\",\n    value: function loadRoute(route) {\n      route = normalizeRoute(route);\n      var scriptRoute = route === '/' ? '/index.js' : \"\".concat(route, \".js\");\n      var url = \"\".concat(this.assetPrefix, \"/_next/static/\").concat(encodeURIComponent(this.buildId), \"/pages\").concat(encodeURI(scriptRoute));\n      this.loadScript(url, route, true);\n    }\n  }, {\n    key: \"loadScript\",\n    value: function loadScript(url, route, isPage) {\n      var _this5 = this;\n\n      var script = document.createElement('script');\n\n      if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n        script.type = 'module'; // Only page bundle scripts need to have .module added to url,\n        // dependencies already have it added during build manifest creation\n\n        if (isPage) url = url.replace(/\\.js$/, '.module.js');\n      }\n\n      script.crossOrigin = process.crossOrigin;\n      script.src = url;\n\n      script.onerror = function () {\n        var error = new Error(\"Error loading script \".concat(url));\n        error.code = 'PAGE_LOAD_ERROR';\n\n        _this5.pageRegisterEvents.emit(route, {\n          error: error\n        });\n      };\n\n      document.body.appendChild(script);\n    } // This method if called by the route code.\n\n  }, {\n    key: \"registerPage\",\n    value: function registerPage(route, regFn) {\n      var _this6 = this;\n\n      var register = function register() {\n        try {\n          var mod = regFn();\n          var pageData = {\n            page: mod[\"default\"] || mod,\n            mod: mod\n          };\n          _this6.pageCache[route] = pageData;\n\n          _this6.pageRegisterEvents.emit(route, pageData);\n        } catch (error) {\n          _this6.pageCache[route] = {\n            error: error\n          };\n\n          _this6.pageRegisterEvents.emit(route, {\n            error: error\n          });\n        }\n      };\n\n      if (true) {\n        // Wait for webpack to become idle if it's not.\n        // More info: https://github.com/zeit/next.js/pull/1511\n        if (module.hot && module.hot.status() !== 'idle') {\n          console.log(\"Waiting for webpack to become \\\"idle\\\" to initialize the page: \\\"\".concat(route, \"\\\"\"));\n\n          var check = function check(status) {\n            if (status === 'idle') {\n              module.hot.removeStatusHandler(check);\n              register();\n            }\n          };\n\n          module.hot.status(check);\n          return;\n        }\n      }\n\n      register();\n    }\n    /**\n    * @param {string} route\n    * @param {boolean} [isDependency]\n    */\n\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(route, isDependency) {\n      var _this7 = this;\n\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      var cn;\n\n      if (cn = navigator.connection) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n      }\n      /** @type {string} */\n\n\n      var url;\n\n      if (isDependency) {\n        url = route;\n      } else {\n        route = normalizeRoute(route);\n        var scriptRoute = \"\".concat(route === '/' ? '/index' : route, \".js\");\n\n        if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n          scriptRoute = scriptRoute.replace(/\\.js$/, '.module.js');\n        }\n\n        url = \"\".concat(this.assetPrefix, \"/_next/static/\").concat(encodeURIComponent(this.buildId), \"/pages\").concat(encodeURI(scriptRoute));\n      }\n\n      return Promise.all(document.querySelector(\"link[rel=\\\"\".concat(relPrefetch, \"\\\"][href^=\\\"\").concat(url, \"\\\"], script[data-next-page=\\\"\").concat(route, \"\\\"]\")) ? [] : [appendLink(url, relPrefetch, url.match(/\\.css$/) ? 'style' : 'script'), process.env.__NEXT_GRANULAR_CHUNKS && !isDependency && this.getDependencies(route).then(function (urls) {\n        return Promise.all(urls.map(function (url) {\n          return _this7.prefetch(url, true);\n        }));\n      })]).then( // do not return any data\n      function () {}, // swallow prefetch errors\n      function () {});\n    }\n  }]);\n\n  return PageLoader;\n}();\n\nexports[\"default\"] = PageLoader;","map":{"version":3,"sources":["../../client/page-loader.js"],"names":["link","document","relPrefetch","hasRel","hasNoModule","route","process","PageLoader","constructor","resolve","window","man","url","assetPrefix","encodeURI","getHrefForSlug","path","buildId","pathname","normalizeRoute","isDynamic","dynamicRegex","dynamicGroups","dynamicMatches","interpolatedRoute","Object","param","value","repeat","Array","encodeURIComponent","s","_dataHref","appendLink","loadPage","loadPageScript","fire","reject","page","mod","cachedPage","error","deps","d","loadRoute","scriptRoute","loadScript","script","register","regFn","pageData","module","console","check","status","cn","navigator","Promise","urls"],"mappings":"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","sourcesContent":["import { parse } from 'url'\nimport mitt from '../next-server/lib/mitt'\nimport { isDynamicRoute } from './../next-server/lib/router/utils/is-dynamic'\nimport { getRouteMatcher } from './../next-server/lib/router/utils/route-matcher'\nimport { getRouteRegex } from './../next-server/lib/router/utils/route-regex'\nimport { delBasePath } from './../next-server/lib/router/router'\n\nfunction hasRel(rel, link) {\n  try {\n    link = document.createElement('link')\n    return link.relList.supports(rel)\n  } catch {}\n}\n\nconst relPrefetch =\n  hasRel('preload') && !hasRel('prefetch')\n    ? // https://caniuse.com/#feat=link-rel-preload\n      // macOS and iOS (Safari does not support prefetch)\n      'preload'\n    : // https://caniuse.com/#feat=link-rel-prefetch\n      // IE 11, Edge 12+, nearly all evergreen\n      'prefetch'\n\nconst hasNoModule = 'noModule' in document.createElement('script')\n\n/** @param {string} route */\nfunction normalizeRoute(route) {\n  if (route[0] !== '/') {\n    throw new Error(`Route name should start with a \"/\", got \"${route}\"`)\n  }\n  route = route.replace(/\\/index$/, '/')\n\n  if (route === '/') return route\n  return route.replace(/\\/$/, '')\n}\n\nfunction appendLink(href, rel, as) {\n  return new Promise((res, rej, link) => {\n    link = document.createElement('link')\n    link.crossOrigin = process.crossOrigin\n    link.href = href\n    link.rel = rel\n    if (as) link.as = as\n\n    link.onload = res\n    link.onerror = rej\n\n    document.head.appendChild(link)\n  })\n}\n\nexport default class PageLoader {\n  constructor(buildId, assetPrefix) {\n    this.buildId = buildId\n    this.assetPrefix = assetPrefix\n\n    this.pageCache = {}\n    this.pageRegisterEvents = mitt()\n    this.loadingRoutes = {}\n    if (process.env.__NEXT_GRANULAR_CHUNKS) {\n      this.promisedBuildManifest = new Promise((resolve) => {\n        if (window.__BUILD_MANIFEST) {\n          resolve(window.__BUILD_MANIFEST)\n        } else {\n          window.__BUILD_MANIFEST_CB = () => {\n            resolve(window.__BUILD_MANIFEST)\n          }\n        }\n      })\n    }\n    /** @type {Promise<Set<string>>} */\n    this.promisedSsgManifest = new Promise((resolve) => {\n      if (window.__SSG_MANIFEST) {\n        resolve(window.__SSG_MANIFEST)\n      } else {\n        window.__SSG_MANIFEST_CB = () => {\n          resolve(window.__SSG_MANIFEST)\n        }\n      }\n    })\n  }\n\n  // Returns a promise for the dependencies for a particular route\n  getDependencies(route) {\n    return this.promisedBuildManifest.then(\n      (man) =>\n        (man[route] &&\n          man[route].map(\n            (url) => `${this.assetPrefix}/_next/${encodeURI(url)}`\n          )) ||\n        []\n    )\n  }\n\n  /**\n   * @param {string} href the route href (file-system path)\n   * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n   */\n  getDataHref(href, asPath) {\n    const getHrefForSlug = (/** @type string */ path) => {\n      path = delBasePath(path)\n      return `${this.assetPrefix}/_next/data/${this.buildId}${\n        path === '/' ? '/index' : path\n      }.json`\n    }\n\n    const { pathname: hrefPathname, query } = parse(href, true)\n    const { pathname: asPathname } = parse(asPath)\n\n    const route = normalizeRoute(hrefPathname)\n\n    let isDynamic = isDynamicRoute(route),\n      interpolatedRoute\n    if (isDynamic) {\n      const dynamicRegex = getRouteRegex(route)\n      const dynamicGroups = dynamicRegex.groups\n      const dynamicMatches =\n        // Try to match the dynamic route against the asPath\n        getRouteMatcher(dynamicRegex)(asPathname) ||\n        // Fall back to reading the values from the href\n        // TODO: should this take priority; also need to change in the router.\n        query\n\n      interpolatedRoute = route\n      if (\n        !Object.keys(dynamicGroups).every((param) => {\n          let value = dynamicMatches[param]\n          const repeat = dynamicGroups[param].repeat\n\n          // support single-level catch-all\n          // TODO: more robust handling for user-error (passing `/`)\n          if (repeat && !Array.isArray(value)) value = [value]\n\n          return (\n            param in dynamicMatches &&\n            // Interpolate group into data URL if present\n            (interpolatedRoute = interpolatedRoute.replace(\n              `[${repeat ? '...' : ''}${param}]`,\n              repeat\n                ? value.map(encodeURIComponent).join('/')\n                : encodeURIComponent(value)\n            ))\n          )\n        })\n      ) {\n        interpolatedRoute = '' // did not satisfy all requirements\n\n        // n.b. We ignore this error because we handle warning for this case in\n        // development in the `<Link>` component directly.\n      }\n    }\n\n    return isDynamic\n      ? interpolatedRoute && getHrefForSlug(interpolatedRoute)\n      : getHrefForSlug(route)\n  }\n\n  /**\n   * @param {string} href the route href (file-system path)\n   * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n   */\n  prefetchData(href, asPath) {\n    const { pathname: hrefPathname } = parse(href, true)\n    const route = normalizeRoute(hrefPathname)\n    return this.promisedSsgManifest.then(\n      (s, _dataHref) =>\n        // Check if the route requires a data file\n        s.has(route) &&\n        // Try to generate data href, noop when falsy\n        (_dataHref = this.getDataHref(href, asPath)) &&\n        // noop when data has already been prefetched (dedupe)\n        !document.querySelector(\n          `link[rel=\"${relPrefetch}\"][href^=\"${_dataHref}\"]`\n        ) &&\n        // Inject the `<link rel=prefetch>` tag for above computed `href`.\n        appendLink(_dataHref, relPrefetch, 'fetch')\n    )\n  }\n\n  loadPage(route) {\n    return this.loadPageScript(route)\n  }\n\n  loadPageScript(route) {\n    route = normalizeRoute(route)\n\n    return new Promise((resolve, reject) => {\n      const fire = ({ error, page, mod }) => {\n        this.pageRegisterEvents.off(route, fire)\n        delete this.loadingRoutes[route]\n\n        if (error) {\n          reject(error)\n        } else {\n          resolve({ page, mod })\n        }\n      }\n\n      // If there's a cached version of the page, let's use it.\n      const cachedPage = this.pageCache[route]\n      if (cachedPage) {\n        const { error, page, mod } = cachedPage\n        error ? reject(error) : resolve({ page, mod })\n        return\n      }\n\n      // Register a listener to get the page\n      this.pageRegisterEvents.on(route, fire)\n\n      // If the page is loading via SSR, we need to wait for it\n      // rather downloading it again.\n      if (document.querySelector(`script[data-next-page=\"${route}\"]`)) {\n        return\n      }\n\n      if (!this.loadingRoutes[route]) {\n        this.loadingRoutes[route] = true\n        if (process.env.__NEXT_GRANULAR_CHUNKS) {\n          this.getDependencies(route).then((deps) => {\n            deps.forEach((d) => {\n              if (\n                /\\.js$/.test(d) &&\n                !document.querySelector(`script[src^=\"${d}\"]`)\n              ) {\n                this.loadScript(d, route, false)\n              }\n              if (\n                /\\.css$/.test(d) &&\n                !document.querySelector(`link[rel=stylesheet][href^=\"${d}\"]`)\n              ) {\n                appendLink(d, 'stylesheet').catch(() => {\n                  // FIXME: handle failure\n                  // Right now, this is needed to prevent an unhandled rejection.\n                })\n              }\n            })\n            this.loadRoute(route)\n          })\n        } else {\n          this.loadRoute(route)\n        }\n      }\n    })\n  }\n\n  loadRoute(route) {\n    route = normalizeRoute(route)\n    let scriptRoute = route === '/' ? '/index.js' : `${route}.js`\n\n    const url = `${this.assetPrefix}/_next/static/${encodeURIComponent(\n      this.buildId\n    )}/pages${encodeURI(scriptRoute)}`\n    this.loadScript(url, route, true)\n  }\n\n  loadScript(url, route, isPage) {\n    const script = document.createElement('script')\n    if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n      script.type = 'module'\n      // Only page bundle scripts need to have .module added to url,\n      // dependencies already have it added during build manifest creation\n      if (isPage) url = url.replace(/\\.js$/, '.module.js')\n    }\n    script.crossOrigin = process.crossOrigin\n    script.src = url\n    script.onerror = () => {\n      const error = new Error(`Error loading script ${url}`)\n      error.code = 'PAGE_LOAD_ERROR'\n      this.pageRegisterEvents.emit(route, { error })\n    }\n    document.body.appendChild(script)\n  }\n\n  // This method if called by the route code.\n  registerPage(route, regFn) {\n    const register = () => {\n      try {\n        const mod = regFn()\n        const pageData = { page: mod.default || mod, mod }\n        this.pageCache[route] = pageData\n        this.pageRegisterEvents.emit(route, pageData)\n      } catch (error) {\n        this.pageCache[route] = { error }\n        this.pageRegisterEvents.emit(route, { error })\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Wait for webpack to become idle if it's not.\n      // More info: https://github.com/zeit/next.js/pull/1511\n      if (module.hot && module.hot.status() !== 'idle') {\n        console.log(\n          `Waiting for webpack to become \"idle\" to initialize the page: \"${route}\"`\n        )\n\n        const check = (status) => {\n          if (status === 'idle') {\n            module.hot.removeStatusHandler(check)\n            register()\n          }\n        }\n        module.hot.status(check)\n        return\n      }\n    }\n\n    register()\n  }\n\n  /**\n   * @param {string} route\n   * @param {boolean} [isDependency]\n   */\n  prefetch(route, isDependency) {\n    // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n    // License: Apache 2.0\n    let cn\n    if ((cn = navigator.connection)) {\n      // Don't prefetch if using 2G or if Save-Data is enabled.\n      if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve()\n    }\n\n    /** @type {string} */\n    let url\n    if (isDependency) {\n      url = route\n    } else {\n      route = normalizeRoute(route)\n\n      let scriptRoute = `${route === '/' ? '/index' : route}.js`\n      if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n        scriptRoute = scriptRoute.replace(/\\.js$/, '.module.js')\n      }\n\n      url = `${this.assetPrefix}/_next/static/${encodeURIComponent(\n        this.buildId\n      )}/pages${encodeURI(scriptRoute)}`\n    }\n\n    return Promise.all(\n      document.querySelector(\n        `link[rel=\"${relPrefetch}\"][href^=\"${url}\"], script[data-next-page=\"${route}\"]`\n      )\n        ? []\n        : [\n            appendLink(\n              url,\n              relPrefetch,\n              url.match(/\\.css$/) ? 'style' : 'script'\n            ),\n            process.env.__NEXT_GRANULAR_CHUNKS &&\n              !isDependency &&\n              this.getDependencies(route).then((urls) =>\n                Promise.all(urls.map((url) => this.prefetch(url, true)))\n              ),\n          ]\n    ).then(\n      // do not return any data\n      () => {},\n      // swallow prefetch errors\n      () => {}\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}